package com.melodytune.backend.service;

import com.melodytune.backend.domain.Member;
import com.melodytune.backend.domain.Review;
import com.melodytune.backend.domain.Store;
import com.melodytune.backend.dto.ReviewRequestDto;
import com.melodytune.backend.dto.ReviewResponseDto;
import com.melodytune.backend.dto.StoreReviewSummaryDto;
import com.melodytune.backend.repository.MemberRepository;
import com.melodytune.backend.repository.ReviewRepository;
import com.melodytune.backend.repository.StoreRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.*;
import org.springframework.beans.factory.annotation.Value;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ReviewService {

    private final ReviewRepository reviewRepository;
    private final StoreRepository storeRepository;
    private final MemberRepository memberRepository; // Member 정보 조회를 위해 필요
    //AI 서버 연결
    //private static final String AI_SERVER_URL = "http://localhost:5000/analyze-reviews";
    @Value("${ai.server.url}")
    private String aiServerBaseUrl; 
    
    // AI 서버의 엔드포인트는 서비스 내부에서 조합합니다.
    private static final String AI_ENDPOINT = "/analyze-reviews"
    // 특정 악기점의 리뷰 조회
    public StoreReviewSummaryDto getReviewsByStoreId(Long storeId) {
        Store store = storeRepository.findById(storeId)
                .orElseThrow(() -> new IllegalArgumentException("업체를 찾을 수 없습니다."));

        // 1. 리뷰 목록 조회 (최신순)
        List<Review> reviews = reviewRepository.findByStoreIdOrderByCreatedAtDesc(storeId);

        // 2. 통계 정보 계산
        Double avgRating = reviewRepository.findAverageRatingByStoreId(storeId);
        Long totalReviews = reviewRepository.countByStoreId(storeId);
        
        // 3. DTO 변환
        List<ReviewResponseDto> reviewDtos = reviews.stream()
                .map(review -> ReviewResponseDto.builder()
                        .reviewId(review.getId())
                        .rating(review.getRating())
                        .content(review.getContent())
                        .userName(review.getMember().getName()) // Member 엔티티에서 이름 접근
                        .createdAt(review.getCreatedAt())
                        .build())
                .collect(Collectors.toList());
        // AI 요약 요청 (리뷰 텍스트 리스트 추출 후 요청)
        List<String> reviewTexts = reviews.stream()
                .map(Review::getContent)
                .collect(Collectors.toList());
        List<String> aiKeywords = getAiSummary(reviewTexts);
        
        return StoreReviewSummaryDto.builder()
                .storeName(store.getName())
                .averageRating(avgRating != null ? avgRating : 0.0)
                .totalReviews(totalReviews != null ? totalReviews : 0L)
                .aiSummary(aiKeywords)
                .reviews(reviewDtos)
                .build();
    }
    
    // Python AI 서버에 리뷰 텍스트를 보내고 키워드 요약을 받아오는 함수
    private List<String> getAiSummary(List<String> reviewTexts) {
        if (reviewTexts.isEmpty()) {
            return Collections.emptyList();
        }

        try {
            // 1. RestTemplate 객체 생성 (HTTP 통신 도구)
            RestTemplate restTemplate = new RestTemplate();

            // 2. 헤더 설정
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);

            // 3. 바디 설정 (Python 서버가 {"texts": [...]} 형태를 기대함)
            Map<String, Object> body = new HashMap<>();
            body.put("texts", reviewTexts);

            HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(body, headers);

            // 4. POST 요청 전송
            // 응답으로 Map을 받습니다. (JSON: {"success": true, "keywords": ["친절", "수리", ...]})
            Map response = restTemplate.postForObject(AI_SERVER_URL, requestEntity, Map.class);

            if (response != null && (Boolean) response.get("success")) {
                return (List<String>) response.get("keywords");
            }

        } catch (Exception e) {
            // AI 서버가 꺼져있거나 오류가 나도 메인 기능(리뷰 목록)은 작동해야 하므로 로그만 남기고 빈 리스트 반환
            System.err.println("AI Server Connection Error: " + e.getMessage());
            return Collections.emptyList();
        }
        return Collections.emptyList();
    }
    
    
    // 새 리뷰 등록 및 갱신
    @Transactional
    public Long createReview(Long storeId, Long memberId, ReviewRequestDto request) {
        // 실제로는 인증 정보를 통해 memberId를 가져와야 합니다. (SecurityConfig 구현 필요)
        Store store = storeRepository.findById(storeId)
                .orElseThrow(() -> new IllegalArgumentException("업체를 찾을 수 없습니다."));
        Member member = memberRepository.findById(memberId)
                .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다."));

        Review newReview = Review.builder()
                .store(store)
                .member(member)
                .rating(request.getRating())
                .content(request.getContent())
                .build();

        Review savedReview = reviewRepository.save(newReview);
        
        updateStoreStatistics(storeId);
        
        return savedReview.getId();
    }
    // 리뷰가 추가/삭제될 때 Store의 평균 평점 및 리뷰 개수 갱신
    @Transactional
    public void updateStoreStatistics(Long storeId) {
        // 1. 통계 데이터 계산 (ReviewRepository의 함수를 사용하여 DB에서 실시간 계산)
        Double newAvgRating = reviewRepository.findAverageRatingByStoreId(storeId);
        Long newTotalReviews = reviewRepository.countByStoreId(storeId);

        // 2. Store 엔티티 조회 및 수정
        Store store = storeRepository.findById(storeId)
                .orElseThrow(() -> new IllegalArgumentException("업체를 찾을 수 없습니다."));
        
        // 3. Store 엔티티 업데이트 메서드 호출
        store.updateStatistics(
            newAvgRating != null ? newAvgRating : 0.0, 
            newTotalReviews
        );
    }
}